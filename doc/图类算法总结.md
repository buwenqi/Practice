2020/9/29

## 图类算法总结

### 图应该怎么存储？
图的标准存储方式有两种：1是临接矩阵，2是临接链表，临接矩阵仅用二维矩阵来存储节点之间的连接关系（可以用来存储权重），
临界表则使用数组+链表来存储节点相连的节点，在Java实现，如果仅使用简单的0,1,2之类的数字代表节点信息，
临接表可以用二维数组int[][]实现，而临接链表则使用List[]数组实现，List[0]代表与0相邻的所有节点。

以上是图的基本存储方式，图应该怎么存储应该根据算法计算方便的方式进行存储，而不应该拘泥于模式。
比如如果要进行拓扑排序的话，使用临接链表可以快速找到所有的相邻节点进行入度减一，宽度有限搜索也是，
在此场景下临接链表的优势更大。如果使用深度优先搜索的话，临接链表也是比临接矩阵有优势。
如果计算最短路径的话，临接链表就不如临接矩阵了，因为我们既要存储权重，又要快速的获取两点之间的权重计算最短值，
所以临接矩阵更合适。例如[Leetcode269. Alien Dictionary]，如果使用深度优先完成递归排序的话，使用临接表存储其父节点深度递归的话，是一个方案。

总体来说，宽度有限搜索和深度优先搜索其实临接链表更合适。最短路径临接矩阵更合适，最小生成树则需要存储边信息，
以点扩展的Prime算法需要存储类似于临接链表的结构（和点相关的边信息链表），而筛选边的Kruskal算法则只需要存储边集和点信息集合就可以。

总之，应该根据处理问题的需要，灵活的改变图存储的方式。

### 图的遍历
图的遍历是解决图各类问题的基础，主要由深度递归遍历和宽度有限遍历，深度有限遍历一般使用递归来完成，
宽度有限遍历用队列完成。以下是两种遍历方式的伪代码实现方式。

深度优先遍历：
```
描述：图的深度有限遍历
输入：图的临接链表表示方式graph
输出：图的s深度右边遍历
1. 初始化visited[]数组标志节点当前的访问状态
2. 循环遍历graph总所有的节点node:
    以node为起始点调用 图的深度有限遍历递归方法
```
```
描述：图的深度有限遍历递归方法
输入：图的临接链表表示方式graph，起始节点node，visited[]标志节点是否已经被访问
输出：从一个节点开始的深度遍历
1. 查看node节点在visited是否已经标志为已访问，如果是，则应该直接返回
2. 访问当前node节点做访问，并标志为已访问
3. 遍历所有node的节点的临接节点nextNode：
    对nextNode做 图的深度有限遍历递归方法
```
宽度优先遍历（从一个节点开始）：
```
描述：图的宽度优先遍历
输入：图的临接链表表示方式graph，初始节点node
输出：从一个节点开始的宽度优先遍历
1. 初始化Queue队列用于存储当前的存储节点，以及访问标志visited
2. 将node节点放入队列，并标志已访问，执行node的访问
3. 如果队列不空的情况下执行如下：
    从队列弹出curNode
    遍历curNode所有的相邻节点nextNode：
        如果nextNode在visited中未访问，执行访问，并把其放入队列中
```

### 图的拓扑排序
图的拓扑排序最好使用临接链表的形式存储，因为可以快速的获取对应节点所有的相邻点，方便对入度数的计算。
拓扑排序的应用是对于有向图，如果有环的话会导致遍历不完所有的节点，所以也可以用来判定环的存在。
拓扑排序使用的宽度优先遍历，因为每次都要将所有入度数为0的节点加入队列进行进一步的遍历。
实现它需要的存储数据包括：图的存储graph，入度统计数组indegree, 以及拓扑排序使用的队列Queue
其基本的实现方式如下：
```
描述：对有向图进行拓扑排序算法
输入：有向图graph
输出：图的拓扑排序
1. 读入图的过程中，初始化入度数组int[] indegree
2. 初始化拓扑排序使用的队列Queue
3. 将所有indegree为0的节点加入Queue中遍历
4. 如果Queue不为空，则循环执行如下：
    4.1 从Queue中弹出一个节点值curNode，执行访问操作
    4.2 循环遍历graph中获取curNode的邻接点：
        4.2.1 将当前的邻接点nextNode在indegree中的度数加一
        4.2.2 如果当前邻接点的度数indegree降为0，则直接将值加入Queue中
```
以上是最标准的拓扑排序，在实际的问题中，可能需要挖掘的点有两个：
一是如何将实际的问题转换成图表示，二是是否可以用拓扑排序或者拓扑排序的变异类型回答相关的问题。
根据以下几个实际的例子，我们来阐释下拓扑排序及其变异在实际情况下的应用：
444. Sequence Reconstruction：验证多个序列是否可以唯一生成一个序列，这个要能想到通过序列建立有向图，
并且执行每层只允许一个节点入度的严苛性拓扑排序，对于不合理的直接返回。类似的题目还有：269. Alien Dictionary

https://leetcode.com/problems/course-schedule/
深度优先也可以进行拓扑排序，但是需要status数组记录当前节点的访问状态
(未访问，在访问子节点，已访问)并且需要栈进行存储操作。

https://leetcode.com/problems/minimum-height-trees/
标准的拓扑排序是应用在有向图上的，这个题目是无向图的题目，这里是拓扑排序思想的高级应用场景
其基本的解法是改将度数为1的节点入队，并且按层遍历，最后一层队列中的结果即是结果

### 图的最小生成树
图的最短路径有两种经典算法，一个是以点扩展边的Prime算法，一个是只筛选边的Kruskal算法，
下面讨论的是在无向图情况下，无向图不需要区分边的起始点和结束点，有向图需要区分
由于两种算法的算法所需要的数据不同，所以存储也有所差异，Prime算法需要快速获取一个节点所有相关的边，
所以需要使用类似于临接链表的方式存储边集合，Kruskal算法需要对所有的边进行排序，需要存储所有的边的集合。
其中边需要用类对象存储Edge存储，包括：oneNode, eitherNode, weight三个域值
以下是两种算法的伪代码实现方式：
```
描述：Prime算法点扩展实现最小生成树
输入：链表存储每个节点相关Edge的图存储List[] 数组 graph, 节点数vnum
输出：最小生成树的边集合
1. 初始boolean[] mark数组标志节点是否已经归入结果集合，初始存储最小生成树最小边的集合List<Edge> result
2. 初始化小根堆PriorityQueue<Edge> heap,用于存储待选边集合，快速获取最小权重的边
3. 随意选择初始节点node，将node所有临接边放入小根堆heap，并将node在mark中标志未已加入最小生成树
4. 当heap不为空且result.size()不等于vnum-1:
    从heap中取出最小权重的边curEdge，及其两个节点oneNode,otherNode
    如果oneNode,otherNode都已经被访问，则该边无效，则应该跳过
    否则，将curEdge加入result中
    如果oneNode为加入最小生成树，将oneNode的边集加入小根堆中
    如果otherNode为加入最小生成树，将otherNode的边集加入小根堆中
5. 返回result
```

```
描述：Kruskal算法边筛选生成最小生成树
输入：边集合List<Edge> edges, 节点数vnum
输出：最小生成树的边集合
1. 初始化并查集int[] root,用于查询连通性
2. 将edges根据权重从小到大排序
3. 将排序后的edges遍历：
    如果result的size()等于vnum-1则提前退出循环
    获取当前edge的两个节点oneNode,otherNode
    在root中获取oneNode的root1,获取otherNode的root2
    如果root1不等于root2,则说明不连通，合法，将root1，root2连通，并将edge加入result
    否则的话，oneNode和otherNode已经连通，直接跳过
4. 返回result
```
相对来说，最小生成树的Kruskal算法实现难度想对较低，可以优先考虑使用，解决的范围是针对一次性覆盖所有节点的路径

### 图的最短路径
图的最短路径计算方法是针对带权图的，如果是不带权的最短路径计算方法可以用宽度优先遍历的层数进行计算，
带权图的最短路径算法有两种计算方法，一种是单源点最短路径的Dijkstra算法，是一种贪心算法。
另一种是多源点最短路径的Floyd算法，是一种插值计算最短路径的动态规划算法。
由于两种算法都需要快速获取两点之间的权重，所以使用临接矩阵存储比较合适。
```
描述：Dijkstra单源点最短路径算法
输入：图的临接权重矩阵int[][] graph,源点vstart,节点数vnum
输出：图的最短路径长度（路径可用记录父节点的方法记录）
1. 初始化flag[vnum]，默认为false, flag[i]==true代表已经计算出最短路径
2. 初始化dist[vnum]，默认为无穷大（可用-1表示），dist[i]代表从vstart到i节点的最短路径长度
(可选，初始化记录路径的int[] path, 默认值为-1，path[i]代表i算出最短路径前的最短路径)
3. 初始标志dist[vstart]=0,并且flag[vstart]=true代表已加入
4. 当前确认最短路径节点为curNode=vstart
5. 循环vnum-1次, 计算出剩余的vnum-1个节点的最短路径：
    5.1 根据curNode更新所有相邻节点的dist:
        5.1.1： i从0循环到vnum-1: 
        5.1.2： 如果flag[i]标志已经访问 或者 graph中[curNode][i]不可达，则直接跳过
        5.2.3： 如果dist[curNode]+ graph[curNode][i]< dist[i]: 
            则直接更新dist[i]=dist[curNode]+ graph[curNode][i]
            （可选，path[i]更新为curNode,代表当前最小路径的父节点为curNode）
    5.2 在所有flag[i]为false中的dist[i]中选出最小的dist[i]
    5.3 更新curNode=最小dist[i]的i
```

```
描述：Floyd多源点最短路径插点算法
输入：图的临接权重矩阵int[][] graph(不可达路径应用无穷大记录，支持复制),节点数vnum
输出：图的最短路径长度（路径可用记录插入点的方法记录）
1. 初始化dist[i][j],代表i到j节点之间的最短路径长度，默认值为graph[i][j]
(可选，用path[i][j]记录i,j之前选择插入的点)
2. 从0到vnum-1选择插入点k遍历
    2.1 遍历i,j对：
    2.2 如果dist[i][k]或者dist[k][j]为无穷大，则不用更新
    2.3 如果dist[i][k]+dist[k][j]<dist[i][j],
        2.3.1 更新dist[i][j]=dist[i][k]+dist[k][j]
        2.3.2 可选：更新path[i][j]=k
3. 输出dist,使用中序遍历恢复path路径
```

### TSP旅行商问题
旅行商问题是指从一个节点出发一次遍历所有节点并且回到原点的最短路径，这里
介绍使用动态规划的思想解决此类问题。
存储：
 1. 图使用邻接矩阵存储，因为要获取任意两点之间的距离
 2. 动态规划矩阵dp[][]:
      表示：
         dp[i][j]代表从i经过j集合回到原点的最小值
          i代表第i个节点
          j代表第集合，二进制表示，例如3（011）代表集合{1,2},0不在j的考虑范围内
      更新：
          动态规划更新应该按列更新，初始集合{},空集dp[i][0]=graph[0][i]，即原点0和i的直达节点
          dp[i][j]=min(dp[k][集合j去掉k后的集合值]),
          其中k是j集合中的任一个值，可以通过遍历获取，集合j去掉k后的集合值可以通过j^(i<<(k-1))获取
 3.算法过程：
```
   1.获取图graph[][],没有联通的话用-1表示
   2. 通过节点数计算n,计算dp j的数量colNum=1<<(n-1),dp[n][colNum],dp初始化均为-1
   3. 初始化dp[i][0] 为graph[i][0]
   4. 列j从1到colNum-1更新：
      遍历所有的点i,查询不在j列表中的点i:
          取出集合j中的一个点k:（从所有的可能中求解min的最小值）
              如果 [i][k]的距离 加上 k经过(j除去k)之后的集合所得的路径长度现在的dp[i][j]:
                  则更新

```
