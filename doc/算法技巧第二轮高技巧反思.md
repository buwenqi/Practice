## 归并排序思想的泛化
典型例题：求一个数组的逆序对（归并合并两个有序数组的时候计算逆序对）
https://leetcode.com/problems/count-of-smaller-numbers-after-self/
https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/
此题目也可以用（维护一个有序数组倒序二分查找，或者排序好后倒序求前缀和）
## 双指针经典题目
https://leetcode.com/problems/container-with-most-water/，双指针移动短板才能获取更大的容量
https://leetcode.com/problems/trapping-rain-water/，两边边走边填充

## 两边遍历贪心算法
https://leetcode.com/problems/candy/，发糖果，第一遍正常加，第二遍反向取max（当前值加后的值，后一个的糖果+1）的值
https://blog.csdn.net/qq_40123329/article/details/100796987，奖品分配，变成环了，用深度优先搜索更新
https://www.cnblogs.com/lixyuan/p/12956542.html

## 头插法贪心算法
https://leetcode.com/problems/queue-reconstruction-by-height/

## 括号问题
### https://leetcode.com/problems/valid-parentheses/
### https://leetcode.com/problems/longest-valid-parentheses/
1. 动态规划：dp[i]代表以i结尾的的最长合法字符串
str[i]==')'时：
* str[i-1]=='(', dp[i]=dp[i-2]+2, i<2时直接等于2
* str[i-1]==')', 需要判定i中跳过i-1指向的最长合法串(i-1-dp[i-1]位置),
    位置是否是'('，如果是，则更新为 dp[i]=dp[i-1]+2+ dp[i-1-dp[i-1]-1]
    否则直接为0
2. 双计数器判定合法性
维护leftCount,rightCount记录左右括号的数量，
正向扫描：如果遇到leftCount==rightCount，说明当前的字符串合法，判定当前的最大字符串长度和当前的哪个大取哪个。
如果遇到leftCount<rightCount,说明当前不合法，并且接下来的字符也不可能再合法，从下一个位置从新计数，leftCount=rightCount=0,归零
正向扫描会丢失以左边开头的合法字符，需要倒序再按照上面的逻辑走一遍，两遍即可成功
### https://leetcode.com/problems/generate-parentheses/
深度优先生成：回溯法
状态：维护可用的leftCount和rightCount
每次尝试放入“（”或者“）”，
出口：leftCount==0 且 rightCount==0
剪枝：1. leftCount<0或者rightCount<0,无可用，2. leftCount<rightCount, 按顺序生成的话，leftCount应该一直>=rightCount,不然的话不合法
### https://leetcode.com/problems/remove-invalid-parentheses/
1. 广度优先，每次递增删除一个
每一层存储的是：删除一个括号后的的字符
转移：当前字符再删除一个括号后所有可能的字符
结果：每一层删除一个后所有的合法字符串，就是删除最少的合法字符
如何检测当前字符是否合法(直接顺序遍历计数法)，不能维护count（左右括号的差值）来解决合法性问题，只能在顺序遍历中使用，删除任意一个字符不能直接通过计数来判定
剪枝策略：遇到新生成的重复的不再加入队列
2. 深度优先+回溯枚举所有可能的删除结果+剪枝
状态是什么？
    1. 当前待选择的字符下标，2. 原字符串，3. 检测是否合法的标准（用左右括号的差值计算）4. 当前生成的字符串,5,结果集合
转移的方式：
    选择删除当前字符：生成的字符不加入当前字符，不删除当前字符：生成的字符加入当前字符，状态更新进入下一层
剪枝策略，1：记录左右括号之差，对于小于0时不再生成，2. 记录需要删除的不合法左右括号的数量（通过计数算出），每次删除时-1，遇到<0时进行剪枝
## 回文字符串问题